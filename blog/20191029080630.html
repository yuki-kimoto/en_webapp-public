<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title>ログイン機能を使ったユーザー認証の作り方 - 会員登録機能の実装 - Mojoliciousスタートアップ - Perlによる新規Web開発</title>
<meta name="description" content="ログイン機能を使ったユーザー認証の作り方について書きます。Webアプリケーションで会員登録の機能を使って、ユーザー認証をするのって、難しそうだなと感じていませんか。どうやって会員登録機能とログイン機能を作ったらよいかわからない、そういう方の疑問を解決できる記事を書きます。">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<h1>
  <a href="/">Mojoliciousスタートアップ - Perlによる新規Web開発</a>
</h1>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <h2><a href="/blog/20191029080630.html">ログイン機能を使ったユーザー認証の作り方 - 会員登録機能の実装</a></h2>
<p>
  ログイン機能を使ったユーザー認証の作り方について書きます。Webアプリケーションで会員登録の機能を使って、ユーザー認証をするのって、難しそうだなと感じていませんか。どうやって会員登録機能とログイン機能を作ったらよいかわからない、そういう方の疑問を解決できる記事を書きます。
</p>
<p>
  記事を書いた後に、Webサービスのスタートアップに必要な、MojoliciousとMySQLにおける会員登録機能とログイン機能を使った、ユーザー認証のサンプルコードを書いてみますね。
</p>
<p>
  この記事を読めば、セキュリティの専門家から見ても、だいじょうぶといえるような、セキュリティ的にも安心の会員登録とログイン機能を、手順を覚えれば実装できるようになります。
</p>
<p>
  (この記事は、2019年におけるもっともよいやり方を試行錯誤しながら書いていますので、検証が必要です。2019年11月5日)
</p>
<h3>ログイン機能を使ったユーザー認証とは何か</h3>
<p>
  ログイン機能を使ったユーザー認証とは何かについて解説していきます。
</p>
<h4>ユーザー認証とは何か</h4>
<p>
  ユーザー認証とは、ユーザーを識別する機能のことを言います。木本さんが操作している、田中さんが操作しているなど、どのユーザーが今操作しているかを識別するための機能です。
</p>
<h4>ログイン機能とは何か</h4>
<p>
  一般的に、Webアプリケーションでは、ユーザーIDとパスワード、あるいは、メールアドレスとパスワードを指定して、ログイン機能を使って、ユーザー認証を実装します。この記事では、この機能のことをログイン機能と呼びます。
</p>
<p>
  ユーザー認証には、ベーシック認証や、OAuthなどの別の認証方式もあるので、アプリケーションで実装するユーザー認証機能をログイン機能という名前で呼ぶことにします。
</p>
<p>
  広くよく見られるログイン画面からログインする機能のことです。
</p>
<h4>ユーザーID</h4>
<p>
  ユーザーIDは「kimoto_yuki01」のように英数字の場合もあれば「0012345」のように数字だけのものもあります。どちらの場合も同じロジックで処理できます。
</p>
<p>
  英数字の場合はASCIIコードの「a-zA-Z0-9_」だけに限定しておくようにすればよいかと思います。
</p>
<p>
  ユーザーIDは、ユーザーが決めることができるようにすることもできますし、サービス提供側が決めることができるようにすることもできます。
</p>
<p>
  ユーザーIDまたは、メールアドレスは、一意であることが必要です。ユニーク制約を設定します。
</p>
<p>
  ユーザーIDを使ってユーザー認証を行う場合は、ユーザーのメールアドレスの変更を行うことができるのは、当然ですが、メールアドレスを使ってユーザー認証を作った場合でも、メールアドレスの変更は可能ですので、安心してください。ユーザーテーブルを作るときに、行を一意に識別できるIDの列を作成して、プライマリーキー制約とオートインクリメントを設定します。
</p>
<h4>パスワードの安全性</h4>
<p>
  パスワードは、ASCIIコードの見ることが可能な文字で表現します。「a-zA-Z0-9」とASCIIの記号「&@」など。キーボードで打てる文字で、文字の制限を行うと考えてください。
</p>
<p>
  セキュリティを高めるために、文字数は、8文字以上と制約を書けると安全です。パスワードは長ければ長いほど安全ですが、利便性もあるので、安全性について、パスワードを決める画面で、ユーザーが知ることができると、親切です。
</p>
<p>
  英語と数字と記号のすべてが入っているというのも、少しだけ安全性を上げるでしょう。
</p>
<p>
  パスワードは、ユーザーテーブルに、そのまま保存しては、絶対にいけません。ユーザーデータが流出すると、そのパスワードをそのまま入力することで、他のサービスにログインできる危険性があるからです。そんなことは、当然だと、思うかもしれませんが、僕はパスワードが生で保存されているテーブルを実際に目にしてきました。
</p>
<p>
  パスワードは、ハッシュ関数を使って、その値を保存します。ハッシュ関数を使うと、元のパスワードが、どんな文字列であったのかを、知ることができません。もう少し、正確に言うと、知ることがほぼ不可能になります。ソルトと呼ばれる値を、付け加えておくと、より安全性が高まります。これについては、後で、詳しく解説します。
</p>
<h4>HTTP通信とユーザー認証</h4>
<p>
  Webの標準的なプロトコルであるHTTP通信は、ステートレスであることが前提です。ステートレスとは、状態を持たないことで、HTTPリクエストがあって、HTTPレスポンスを返すというのがひとつの処理で、それぞれのHTTPリクエストが独立しています。
</p>
<p>
  HTTP自体は、接続を持続するという機能を持っていません。(HTTP 2.0のことはこの記事では触れません)。
</p>
<p>
  ベーシック認証や、ダイジェスト認証が定義されていますが、これは、HTTP通信上の認証なので、アプリケーションに統合することができません。
</p>
<p>
  結局のところ、ユーザーにサービスを提供するためのユーザー認証は、アプリケーション側で、行う必要があるということです。
</p>
<p>
  HTTPは、クッキーと呼ばれる、クライアント側にデータを保存する機能を持っています。このクッキーの機能をうまく使って、ユーザー認証を実装することになります。
</p>
<p>
  ログインのタイミングで、セッションIDと呼ばれるものを、アプリケーション側で発行して、それを、クッキーに保存してもらいます。そして、クッキーに保存されたセッションIDを、送信してもらい、アプリケーション側で、ユーザーを識別します。
</p>
<h3>パスワードをどのように保存するか</h3>
<p>
  ログイン機能を使ったユーザー認証を作る場合は、ユーザーがパスワードを入力します。このパスワードを盗まれても安全なように保存しておく必要があります。
</p>
<p>
  パスワードそのままを保存した場合は、サーバーで作業している人は、データベースでSQLを実行して、ユーザーIDとパスワードをそのまま見ることができます。これは、セキュリティ上よろしくありません。
</p>
<p>
  ですので、パスワードをそのまま保存するのではなく、パスワードにハッシュ関数を実行した値を保存しておくことになります。
</p>
<h4>ハッシュ関数とは</h4>
<p>
  ハッシュ関数とは、ある値を与えたときに、ひとつの値を出力する関数です。
</p>
<pre>
# ハッシュ関数
my $hash_value = hash_func($value);
</pre>
<p>
  「えっ、これがハッシュ関数」なのと言われると、これがハッシュ関数なのだというしかありません。すごく難しいと信じ込んでいた方は、びっくりされるでしょう。
</p>
<p>
  ただし、良いハッシュ関数と悪いハッシュ関数があり、良いハッシュ関数を選ぶ必要があるのです。
</p>
<p>
  良いといわれるハッシュ関数の条件は以下です。
</p>
<ul>
  <li>ハッシュ値から元の値を推測されないこと</li>
  <li>異なる入力に対して、出力されるハッシュ値がなるべく重複しないこと</li>
</ul>
<p>
  元の値を推測されるということは、パスワードが知られてしまうということです。パスワードが簡単に知られてしまうようでは、困りますね。ですので、良いハッシュ関数は、元の値を推測されにくいということが必要です。
</p>
<p>
  パスワードの場合は、ハッシュ値が重複しないことは、あまり必要な要件ではありませんが、ハッシュ値を、ユニークIDとして扱いたい場合は、異なる入力に対して、出力されるハッシュ値がなるべく重複しないということが重要です。これは、後ほど、セッションIDを作成する上で、必要になりますので、頭に入れておいてください。
</p>
<p>
  ちなみに、ハッシュ関数は、Perlのハッシュとは何の関係もありません。
</p>
<h4>bcryptでパスワードをハッシュ化する</h4>
<p>
  2019年の調査の結果、パスワードをハッシュ化するには、bcryptが良いようです。PHP 7では、bcryptのアルゴリズムが、デフォルトで採用されています。
</p>
<p>
  bcryptは、入力値が短くても(パスワードは短い)、元の値を推測するのに、ある程度の計算時間がかかるハッシュ関数のアルゴリズムのようです。
</p>
<p>
  Perlにおけるbcryptの実装は<a href="https://metacpan.org/pod/release/ZEFRAM/Crypt-Eksblowfish-0.009/lib/Crypt/Eksblowfish.pm">Crypt::Eksblowfish::Bcrypt</a>で利用できます。
</p>
<p>
  Mojoliciousでは、プラグインとして<a href="https://metacpan.org/pod/release/MINIMAL/Mojolicious-Plugin-Bcrypt-0.14/lib/Mojolicious/Plugin/Bcrypt.pm">Mojolicious::Plugin::Bcrypt</a>があります。
</p>
<pre>
# 登録時にハッシュ化されたパスワードを作る
sub signup {
    my $self = shift;
    my $crypted_pass = $self-&gt;bcrypt( $self-&gt;param('password') );
    ...
}

# ログイン時にパスワードをチェック
sub login {
    my $self = shift;
    my $entered_pass = $self-&gt;param('password');
    my $crypted_pass = $self-&gt;get_password_from_db();
    if ( $self-&gt;bcrypt_validate( $entered_pass, $crypted_pass ) ) {
 
        # Authenticated
        ...;
    }
    else {
 
        # Wrong password
        ...;
    }
}
</pre>
<p>
  bcryptで生成されたハッシュ化されたパスワードを、ユーザーテーブルのパスワードに保存しましょう。
</p>
<p>
  将来的にさらに強度の高いアルゴリズムがでてきた場合のために、bcryptを自作のpassword_hash関数で、bcrypt_validateを自作のpassword_validate関数で、ラッピングしておくと、保守性が高くなるかもしれませんね。
</p>
<p>
  Mojolicious以外の場合は、Mojolicious::Plugin::Bcryptのソースコードは、Mojoliciousに依存していなくて、とても簡単なので、コピペして利用できそうです。
</p>
<h3>セッションIDを生成する方法</h3>
<p>
  ユーザー認証において、少し難しいのは、初回のログイン以外は、セッションIDを使って、ユーザーを識別するということです。
</p>
<p>
  ログイン画面から、ログインをするときは、ユーザーIDとパスワードを使ってユーザーを認証するのですが、認証後は、セッションIDを使ってユーザーを識別します。
</p>
<h4>セッションIDとは</h4>
<p>
  セッションIDとは、ユーザーを識別するための文字の並びのことです。セッションIDのサンプルを書いてみます。
</p>
<pre>
# セッションIDのサンプル
aabc73ce3
deab33cea
a567c73c1
</pre>
<p>
  本物のセッションIDはもっと長い方がよいのですが、ここでは雰囲気だけ。16進数の文字を並べていますが、「a-z」「A-Z」「0-9」などのランダムな文字の並びで構いません。
</p>
<h4>セッションIDは一意性が高く、十分に長くなければならない</h4>
<p>
  セッションIDは、単なる文字列の並びですが、ユーザー識別に利用するために、いくつかの要件を満たしている必要があります。
</p>
<p>
  ユーザー識別には、まずそのユーザーを識別できるということが求められます。
</p>
<p>
  たとえば、ユーザーが1万人いるとしたら、セッションIDが5000人分しかないと、困りますね。
</p>
<p>
  また、セッションIDを発行したときに、他のユーザーと重なってしまったというのも困りますね。
</p>
<p>
  またセッションIDが短ければ、推測される可能性も高まります。セキュリティ的にも、文字の種類が多く、長い方がよいのです。
</p>
<p>
  セッションIDは単なるランダムな文字列の並びで良いのですが、一意性を確保したい場合に、衝突が起こるのが極めて小さいハッシュ関数を使うのが簡単です。
</p>
<p>
  ハッシュ関数で生成する場合は、文字種は「0-9a-z」の16文字ですので、なるべく文字の長さが長くなるようにするのが安全です。
</p>
<p>
  SHA-1で40文字、SHA-256で64文字、SHA-512で128文字です。
</p>
<pre>
SHA-1
356a192b7913b04c54574d18c28d46e6395428ab

SHA-256
6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b

SHA-512
4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a
</pre>
<p>
  セッションIDは、ユーザーが覚える必要がないので長くしても大丈夫です。
</p>
<h4>セッションIDは、ユーザーを識別し、永続的ではなく、推測されにくい必要がある</h4>
<p>
  セッションIDを作成する場合に、ハッシュ関数を使うのですが、入力を何にするかということは、考える必要があります。
</p>
<p>
  もし、ユーザー名にすれば、簡単に推測されてしまいそうです。この場合、ユーザー名とハッシュ関数の種類がわかれば、出力がわかるわけですね。
</p>
<p>
  また、セッションIDが永続的に変わらないということにもなってしまします。セッションIDは、期限が来ると無効になる必要があるわけです。
</p>
<p>
  時刻の情報を、ユーザー名の末尾に、付け足しましょう。こうすると永続性はなくなります。ユーザー名に対して一意ということもありません。
</p>
<p>
  これで、十分でしょうか? まぁ、心配はなさそう? でも、もう少しセッションIDを強くしましょう。
</p>
<p>
  ユーザー名と時刻というのは、ランダムな情報ではないですよね。攻撃者は、ユーザー名と時刻とハッシュ関数がわかれば、突破できます。
</p>
<p>
  そこで、ランダムな数字というのを、末尾に付け足してあげます。100万くらいにしておきましょうか。
</p>
<p>
  100万以下のランダムな数字を付け加える。
</p>
<p>
  ですので、上記を踏まえて、セッションIDを生成してみましょう。ユーザー名と時刻とランダムな数をSHA-512のアルゴリズムのハッシュ関数に与えています。
</p>
<pre>
use strict;
use warnings;

use Digest::SHA 'sha512_hex';

# セッションIDを作成
my $user_id = 'kimoto';
my $time = time;
my $rand = int rand 1_000_000;
my $session_id = sha512_hex($user_id . $time . $rand);
print "$session_id\n";
</pre>
<p>
  出力されたセッションIDの例
</p>
<pre>
e182aa93605c82a472c4986f2749b111f35042f2bb01a3ba9eba3603653cf5ca4d9eb540f1ae32eb4c8d280f18ccb4d5f58f614652c067c7c3175e9b58d29d1a
</pre>
<p>
  ちなみにMojoliciousのセッション機能は、セッションIDを生成する方法とは何の関係もないので注意してください。Mojoliciousのセッションは、セッションIDを保存するのに利用できます。
</p>
<pre>
$c-&gt;session(session_id =&gt; $session_id);
</pre>
<h3>セッションIDをどこに保存するか</h3>
<p>
  セッションIDはログインのタイミングで発行しますが、これをどこに保存しておくのでしょうか?
</p>
<p>
  セッションIDは二か所に保存しておく必要があります。それは、クライアントのクッキーと、サーバー側のユーザーのIDに紐づけられた場所、たとえばユーザーテーブルに保存します。
</p>
<h3>セッションIDをクライアントのクッキーに保存</h3>
<p>
  クライアントは、クッキーに保存されたセッションIDをサーバーに送信することで、ユーザー認証をしてもらいます。セッションIDの期限が切れていなければ、あなたであるということが、サーバー側で分かるという仕組みです。
</p>
<p>
  Mojoliciousでは、セッションという機能を使って、セッションIDを保存できます。Mojoliciousのセッションは、この記事で書かれている、セッションIDとは何の関係もないので注意してください。
</p>
<p>
  Mojoliciousのセッションは、クッキーをより安全に利用できるようにした機能だと考えておくのがよいでしょう。電子署名が付いているので、改ざんされた場合に、検知できるという機能がクッキーに追加されたというものです。
</p>
<p>
  暗号化はされていませんので、ユーザーを識別できるような情報、たとえば、ユーザーIDやパスワードを保存しておくのに適していません。解読は簡単で、もし生のパスワードを保存したとすれば、クッキーを盗まれたときに、わかってしまいます。
</p>
<p>
  Mojoliciousのセッション(署名付きクッキー)に、セッションIDを保存します。これは、ユーザーがログインしたタイミングで、一度だけ行います。
</p>
<pre>
Mojoliciousのセッション(署名付きクッキー)にセッションIDを保存
$c-&gt;session(session_id =&gt; $session_id);
</pre>
<p>
  Mojoliciousではない場合も、フレームワークのクッキーに保存する機能を利用すれば、同じです。
</p>
<h3>セッションIDをサーバー側のユーザーIDが紐づけられた場所に保存</h3>
<p>
  セッションIDを保存する場所は、サーバー側であれば、ユーザーIDと紐づけることができれば、どこでも構いません。メモリであったり、ファイルであったり、リレーショナルデータベース(MySQL, PostgreSQL)であったり、揮発性のキーバリューストアー(Redis, memcached)であったりします。
</p>
<p>
  メモリである場合は、サーバーが、フォークしている場合対応できません。ファイルであった場合は、アプリケーションサーバーが、並列に並んでいるときは対応できません。リレーショナルデータベースは、データべースへのアクセスがあります。揮発性のキーバリューストアーは、リレーショナルデータベースよりは速いですが、サーバーをインストールし、利用するコストがあります。
</p>
<p>
  Mojoliciousスタートアップは、Webの新規開発がPerlでできるようになるサイトですので、複雑性を避けて応用が利きやすいように、リレーショナルデータベースを使った方法を紹介します。
</p>
<p>
  基本的な考え方がわかれば、他の方法にすることができると思います。
</p>
<p>
  この記事では、MySQLとPerlのDBIをサンプルにして、紹介しますね。
</p>
<h4>セッション管理のためのユーザーテーブル定義</h4>
<p>
  ユーザーテーブルは以下のようにします。MySQLの設定でデータベースはInnoDBで、文字コードがutf8mb4であるとします。必ずInnoDBをデフォルトのテーブルのエンジンとして、設定してください。InnoDBは行ロックの機能を持っており、テーブル全体をロックしません。
</p>
<pre>
create table USER (
  ID int primary_key auto_increment,
  CODE varchar(150) not null default '',
  NAME varchar(150) not null default '',
  MAIL varchar(150) not null default '',
  SESSION_ID varchar(150),
  SESSION_EXPIRATION bigint not null default 0,
  unique(CODE),
  unique(MAIL),
  unique(SESSION_ID)
);
</pre>
<p>
  主要な点は、セッションに関する部分ですが、どのような考えに基づいて、このユーザーテーブルなのかを簡潔に書きます。
</p>
<p>
  まず、テーブル名と列名が大文字であるのは、ちょっとタイピングは不便ですが、データとロジックを明確に分けられるという利点があります。Perlのロジックは、$userやget_userのように小文字のスネークケースで書かれるので、大文字のスネークケースにしておくと、実際にデータベースにアクセスしているデータの場所が、grepで検索した場合に、すぐにわかるということがあります。まぁ、これは、趣味の範囲内といえるので、プロジェクトの方針に従いましょう。
</p>
<p>
  ユーザーIDが、int型でauto_incrementであるのは、ユーザーは、登録されるデータだからです。列を一意に識別できるIDを持たせています。CODEというのはkimotoのような、ユーザー名と呼ばれているものですが、木本裕紀のようなユーザー名の本名を区別するために、CODEという名前にしています。本名はNAMEに入ります。
</p>
<p>
  MAILはメールアドレスで、会員登録する場合は、メールを送信して、本人確認をするので、必要です。メールアドレスは重複がないようにユニーク制約をつけています。
</p>
<p>
  mysqlでは、varchar(150)というのは、varcharは255までであれば、どの長さにしても、保存サイズも変わらないということで、なるべく大きな150という値にしています。
</p>
<p>
  mysqlには、古いMySQLの場合、utf8mb4を指定した場合は、インデックスが191の長さまでしか効かないという仕様がありますので、環境依存の落とし穴にはまらないように、191より小さく覚えやすい150にしています。
</p>
<p>
  not null制約は、nullを許可しなければならない絶対的な必要性がない限りは、つけておきます。アプリケーションのロジックにおいて、NULLを排除しておいた方が、判定が簡単だからです。
</p>
<p>
  さてここからがセッションのお話です。セッションIDは、ユニークでなければならないので、ユニーク制約をつけます。ただし、not null制約はつけません。会員登録した段階では、セッションIDが存在しないからです。クッキーに保存されているセッションIDがわかれば、ユーザーテーブルを検索して、どのユーザーからのアクセスなのかを判定できます。
</p>
<p>
  セッションは有効期限を持ちますが、bigintで、64bit整数型で保存しておくと2019年問題をクリアできます。datetime型ではない理由は、セッションIDのチェックのたびに、日付の変換のロジックを書かなくてもよいという理由です。セッションは、ユーザーがどのページにアクセスした場合にも、チェックする必要がありますから、なるべくパフォーマンスが良い方がよいのです。
</p>
<p>
  ユーザーが増えてきて、セッションのチェックによる、アプリケーションサーバーのコストが判明したタイミングが、保存先をリレーショナルデータベースから、揮発性のキーバリューストアに、切り替えるタイミングかと思われます。
</p>
<h4>セッションIDの保存</h4>
<p>
  セッションIDは、ログインしたタイミングで発行しますが、このタイミングで、ユーザーテーブルのセッションに保存しましょう。セッションの有効期間は、2週間とします。セッションIDは「セッションIDを生成する方法」で解説したセッションIDです。サンプルでは、DBIの例外処理は、書いていませんが、実際は、書いてください。
</p>
<pre>
# セッションを保存。期限は二週間後。
my $two_week_seconds = (60 * 60 * 24 * 14);
my $session_expiration = time + $two_week_seconds;
my $sth = $dbi-&gt;prepare('update USER set SESSION_ID = ?, SESSION_EXPIRATION = ?');
$sth-&gt;execute($session_id, $session_expiration);
</pre>
<p>
  もし、セッションIDにはユニーク制約がついているので、重複した場合は、この処理は失敗しますが、重複する確率が非常に小さいようにセッションIDを作っていますので、重複する確率は、天文学的に小さくなるでしょう。
</p>
<p>
  絶対に起こらないようにしたい場合は、失敗した場合に、セッションIDを発行して、処理を繰り返しましょう。
</p>
<h4>セッションの確認</h4>
<p>
  ユーザーがログインしている場合は、クッキーにセッションIDが保存されています。クッキーに保存されているセッションIDを、データベースに保存されているユーザーIDと比較しましょう。
</p>
<p>
  セッションIDが一致することと、有効期限が切れていないことを確認しましょう。
</p>
<p>
  MojoliciousとDBIによるコードのサンプルです。
</p>
<pre>
# クッキーからセッションIDを取得
my $cookie_session_id = $c-&gt;session('session_id');

# 現在時刻を取得
my $cur_time = time;

# セッションが一致して、有効期限が切れていない、ユーザー情報を取得
my $sth = $dbi-&gt;prepare('select ID, SESSION_EXPIRATION from USER where SESSION_ID = ?, SESSION_EXPIRATION &lt; ?');
$sth-&gt;execute($cookie_session_id, $cur_time);
my $user = $sth-&gt;fetchrow_hashref;
$sth-&gt;finish;

# もしなければ、認証失敗
unless ($user) {
  # 認証失敗した場合の処理を書く
}

# ユーザーIDを取得
my $user_id = $user-&gt;{ID};

# 現在のセッションの有効期限を取得
my $user_session_expiration = $user-&gt;{SESSION_EXPIRATION};
</pre>
<p>
  セッションが確認できれば、だれがログインしているがわかりますね。必要な情報はユーザーIDだけですが、セッションの有効期限の更新で利用するために、セッションの有効期限も取得しています。
</p>
<h4>セッションの有効期限の更新</h4>
<p>
  ユーザーがログインを継続的に行っている間は、セッションを更新しましょう。最終ログインの日時から、2週間ログインがなかった場合に、セッションが切れるという実装にしてみましょう。
</p>
<p>
  ここでひとつ考えておく必要があるのは、updateによる更新処理は、selectよりも負荷が高いということです。selectは、スケールアウトしやすのですが、updateはマスターのデータベースを必ず更新しなければならないため、スケールアウトしにくいのです。また、update処理が行われる場合は、MySQLのInnoDBでは、対象の行がロックされます。
</p>
<p>
  updateは、スケールアウトしにくいということと、行にロックがかかるという点が、selectとは異なるということを、覚えておきましょう。
</p>
<p>
  ですので、アクセスがあるたびに、セッションの有効期限を更新という処理は書きたくないですね。ここでは、1日に1回だけセッションの有効期限を更新するというロジックにしてみましょう。
</p>
<p>
  DBIを使ったサンプルです。変数名は、上記のサンプルから引きついだものもあります。
</p>
<pre>
# 新しい有効期限は、現在から2週間後に設定
my $new_user_session_expiration = $cur_time + $two_week_seconds;

# 1日の秒数
my $one_day_seconds = 60 * 60 * 24;

# 有効期限が1日以内に更新されていない場合に、更新する
if ($new_user_session_expiration &gt; $user_session_expiration + $one_day_seconds) {
  my $sth = $dbi-&gt;prepare('update USER set SESSION_EXPIRATION = ? from USER where ID = ?');
  $sth-&gt;execute($new_user_session_expiration, $user_id);
}
</pre>
<h3>検討事項</h3>
<p>
  セキュリティの専門家の方に聞きたいこと。
</p>
<p>
  パスワード認証は、bcryptでよいか?
</p>
<p>
  セッションIDがSHA-512の場合に、128文字になるが、不具合がでてくる事象はないか?
</p>
<p>
  (記事執筆途中。追加、修正あり。実際の全体の検証は未。最終更新2019年11月1日)
</p>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    目次
  </div>
  <ul>
    <li><a href="/list.html">記事の一覧</a></li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="http://www.perlzemi.com">Perlゼミ公式</a> & <a href="https://jp.giblog.net/">Giblog</a>

      </div>
    </div>
  </body>
</html>
